<?php

use Html\Delegator\HTMLDocumentDelegator;
use Html\Element\Block\Body;
use Html\Element\Inline\Anchor;
use Html\Interface\TemplateGeneratorInterface;
use Html\TemplateGenerator\TypeScriptGenerator;

beforeEach(function () {
    $this->generator = new TypeScriptGenerator();
});

test('implements interface', function () {
    expect($this->generator)->toBeInstanceOf(TemplateGeneratorInterface::class);
});

test('constructor', function () {
    expect($this->generator)->toBeInstanceOf(TypeScriptGenerator::class);
});

test('get extension', function () {
    expect($this->generator->getExtension())
        ->toBe('ts');
});

test('get name pattern', function () {
    expect($this->generator->getNamePattern())
        ->toBe('{component}.{extension}');
});

test('can render elements', function () {
    expect($this->generator->canRenderElements())
        ->toBeTrue();
});

test('can render documents', function () {
    expect($this->generator->canRenderDocuments())
        ->toBeFalse();
});

test('is templated', function () {
    expect($this->generator->isTemplated())
        ->toBeFalse();
});

test('render element', function () {
    $document = HTMLDocumentDelegator::createEmpty();
    $element = Anchor::create($document);
    $element->setHref('https://example.com');
    $result = $this->generator->render($element);
    expect($result)
        ->toBeString();
    expect($result)
        ->toContain('interface');
    expect($result)
        ->toContain('class');
});

test('render document', function () {
    $document = HTMLDocumentDelegator::createEmpty();
    $element = Body::create($document);
    $document->appendChild($element);
    $result = $this->generator->render($document);
    expect($result)
        ->toBeNull();
});

test('render invalid', function () {
    expect($this->generator->render('string'))
        ->toBe(null);
});

test('render composed element with parent of', function () {
    $document = HTMLDocumentDelegator::createEmpty();
    $element = Anchor::create($document);

    // Use reflection to set parentOf property
    $ref = new ReflectionClass($element);
    $ref->setStaticPropertyValue('parentOf', ['Html\\Element\\Inline\\Span']);

    $result = $this->generator->renderComposedElement($element);
    expect($result)
        ->toBeString();
    expect($result)
        ->toContain('THIS FILE IS AUTOGENERATED');
    expect($result)
        ->toContain('Composed Example');
});

test('render composed element excluded element', function () {
    $document = HTMLDocumentDelegator::createEmpty();
    $element = Body::create($document);

    $result = $this->generator->renderComposedElement($element);
    expect($result)
        ->toBeNull();
});

test('render composed element no parent of', function () {
    $document = HTMLDocumentDelegator::createEmpty();
    $element = Anchor::create($document);

    // Anchor actually has parentOf set, so it should return a string
    $result = $this->generator->renderComposedElement($element);
    expect($result)
        ->toBeString();
    expect($result)
        ->toContain('THIS FILE IS AUTOGENERATED');
});

test('get global attribute traits', function () {
    $document = HTMLDocumentDelegator::createEmpty();
    $element = Anchor::create($document);

    $ref = new ReflectionClass($this->generator);
    $method = $ref->getMethod('getGlobalAttributeTraits');
    $method->setAccessible(true);

    $traits = $method->invoke($this->generator, $element);
    expect($traits)
        ->toBeArray();
    expect($traits)
        ->toHaveKey('className');
    expect($traits)
        ->toHaveKey('id');
});

test('uses trait', function () {
    $document = HTMLDocumentDelegator::createEmpty();
    $element = Anchor::create($document);
    $ref = new ReflectionClass($element);

    $method = new ReflectionMethod($this->generator, 'usesTrait');
    $method->setAccessible(true);

    $result = $method->invoke($this->generator, $ref, 'Html\\Trait\\GlobalAttribute\\HrefTrait');
    expect($result)
        ->toBeBool();
});

test('trait to property name', function () {
    $method = new ReflectionMethod($this->generator, 'traitToPropertyName');
    $method->setAccessible(true);

    expect($method->invoke($this->generator, 'ClassTrait'))
        ->toBe('className');
    expect($method->invoke($this->generator, 'IdTrait'))
        ->toBe('id');
    expect($method->invoke($this->generator, 'HrefTrait'))
        ->toBe('href');
});

test('build composed typescript', function () {
    $ref = new ReflectionClass('Html\\Element\\Inline\\Anchor');

    $method = new ReflectionMethod($this->generator, 'buildComposedTypeScript');
    $method->setAccessible(true);

    $result = $method->invoke($this->generator, 'anchor', 'Anchor', 'Test description', $ref, [], ['Span']);
    expect($result)
        ->toBeString();
    expect($result)
        ->toContain('THIS FILE IS AUTOGENERATED');
    expect($result)
        ->toContain('Composed Example');
    expect($result)
        ->toContain('import { Anchor }');
});

test('determine level', function () {
    $method = new ReflectionMethod($this->generator, 'determineLevel');
    $method->setAccessible(true);

    expect($method->invoke($this->generator, 'Html\\Element\\Block\\Div'))
        ->toBe('block');
    expect($method->invoke($this->generator, 'Html\\Element\\Inline\\Span'))
        ->toBe('inline');
    expect($method->invoke($this->generator, 'Html\\Element\\Void\\Img'))
        ->toBe('void');
    expect($method->invoke($this->generator, 'SomeOtherClass'))
        ->toBe('block');
});
