/**
 * THIS FILE IS AUTOGENERATED. DO NOT EDIT IT.
 *
 * @generated November 7, 2025 17:10:34
 * @component Ordered List
 * @description The ol element represents an ordered list of items. The order of the list is meaningful.
 */

import React from 'react';

export interface OlProps {
  /** The content to display in the element */
  children?: React.ReactNode;
  /** CSS class names */
  className?: string;
  accesskey?: string;
  /** Identifies the currently active child element (e.g., for autocomplete suggestions or composite widgets). */
  ariaActivedescendant?: string;
  /** Indicates whether assistive technologies should present the entire region as a whole when changes occur. */
  ariaAtomic?: 'false' | 'true';
  /** The aria-busy attribute is used to indicate whether an element is currently busy or not. */
  ariaBusy?: 'true' | 'false';
  /** Identifies the element(s) whose contents or presence are controlled by this element. Value is a list of IDs separated by a space */
  ariaControls?: string;
  /** Identifies the element(s) that describes the object. Value is a list of IDs separated by a space */
  ariaDescribedby?: string;
  /** References an element that provides additional details about the current element. */
  ariaDetails?: string;
  /** Indicates whether the element is exposed to an accessibility API. Use with caution on interactive elements. Set to true only on decorative elements such as icons, or when nav isnt visible */
  ariaHidden?: 'false' | 'true';
  /** Defines keyboard shortcuts available for the element. */
  ariaKeyshortcuts?: string;
  /** Identifies the element(s) that labels the current element. Value is a list of IDs separated by a space */
  ariaLabelledby?: string;
  /** Defines how updates to the element should be announced to screen readers. */
  ariaLive?: 'off' | 'polite' | 'assertive';
  /** Defines whether multiple items can be selected in a listbox, grid, or tree. */
  ariaMultiselectable?: 'false' | 'true';
  /** Specifies whether an element is horizontal or vertical. */
  ariaOrientation?: 'horizontal' | 'vertical' | 'undefined';
  /** Establishes ownership relationships between elements. Value is a space-separated list of IDs. */
  ariaOwns?: string;
  /** Indicates what content changes should be announced in a live region. */
  ariaRelevant?: 'additions' | 'removals' | 'text' | 'all' | 'additions text';
  /** Provides a human-readable custom role description for assistive technologies. */
  ariaRoledescription?: string;
  autocapitalize?: 'none' | 'sentences' | 'words' | 'characters';
  autofocus?: boolean;
  contenteditable?: 'true' | 'false' | 'inherit';
  /** Custom data attributes (data-*) */
  data?: Record<string, string>;
  dir?: 'ltr' | 'rtl' | 'auto';
  draggable?: boolean;
  hidden?: boolean;
  id?: string;
  inputmode?: 'none' | 'text' | 'decimal' | 'numeric' | 'email' | 'tel' | 'url' | 'search';
  lang?: string;
  popover?: 'auto' | 'hint' | 'manual';
  /** When present, it specifies that the list order should be descending (9,8,7...). */
  reversed?: boolean;
  /** Defines the semantic purpose of an element for assistive technologies. */
  role?: 'alert' | 'application' | 'article' | 'banner' | 'button' | 'checkbox' | 'complementary' | 'contentinfo' | 'dialog' | 'form' | 'grid' | 'group' | 'heading' | 'img' | 'link' | 'list' | 'listbox' | 'listitem' | 'main' | 'menu' | 'menubar' | 'menuitem' | 'navigation' | 'none' | 'presentation' | 'radio' | 'region' | 'search' | 'status' | 'tab' | 'tablist' | 'tabpanel' | 'textbox' | 'toolbar' | 'tooltip';
  slot?: string;
  spellcheck?: 'true' | 'false';
  /** Specifies the starting value of an ordered list. */
  start?: number;
  style?: React.CSSProperties;
  tabindex?: number;
  title?: string;
  translate?: 'yes' | 'no';
  /** Specifies the numbering type of the ordered list. */
  type?: 'a' | 'A' | 'i' | 'I' | '1';
}

/**
 * Ordered List - The ol element represents an ordered list of items. The order of the list is meaningful.
 */
export const Ol: React.FC<OlProps> = (props: OlProps) => {
  const {
    children,
    className,
    accesskey,
    ariaActivedescendant,
    ariaAtomic,
    ariaBusy,
    ariaControls,
    ariaDescribedby,
    ariaDetails,
    ariaHidden,
    ariaKeyshortcuts,
    ariaLabelledby,
    ariaLive,
    ariaMultiselectable,
    ariaOrientation,
    ariaOwns,
    ariaRelevant,
    ariaRoledescription,
    autocapitalize,
    autofocus,
    contenteditable,
    data,
    dir,
    draggable,
    hidden,
    id,
    inputmode,
    lang,
    popover,
    reversed,
    role,
    slot,
    spellcheck,
    start,
    style,
    tabindex,
    title,
    translate,
    type
  } = props;

  const elementProps: React.HTMLAttributes<HTMLElement> & Record<string, any> = {};

  if (className) {
    elementProps.className = className;
  }

  if (data) {
    Object.entries(data).forEach(([key, value]) => {
      elementProps[`data-${key}`] = value;
    });
  }

  if (accesskey !== undefined) {
    elementProps['accesskey'] = accesskey;
  }

  if (ariaActivedescendant !== undefined) {
    elementProps['aria-activedescendant'] = ariaActivedescendant;
  }

  if (ariaAtomic !== undefined) {
    elementProps['aria-atomic'] = ariaAtomic;
  }

  if (ariaBusy !== undefined) {
    elementProps['aria-busy'] = ariaBusy;
  }

  if (ariaControls !== undefined) {
    elementProps['aria-controls'] = ariaControls;
  }

  if (ariaDescribedby !== undefined) {
    elementProps['aria-describedby'] = ariaDescribedby;
  }

  if (ariaDetails !== undefined) {
    elementProps['aria-details'] = ariaDetails;
  }

  if (ariaHidden !== undefined) {
    elementProps['aria-hidden'] = ariaHidden;
  }

  if (ariaKeyshortcuts !== undefined) {
    elementProps['aria-keyshortcuts'] = ariaKeyshortcuts;
  }

  if (ariaLabelledby !== undefined) {
    elementProps['aria-labelledby'] = ariaLabelledby;
  }

  if (ariaLive !== undefined) {
    elementProps['aria-live'] = ariaLive;
  }

  if (ariaMultiselectable !== undefined) {
    elementProps['aria-multiselectable'] = ariaMultiselectable;
  }

  if (ariaOrientation !== undefined) {
    elementProps['aria-orientation'] = ariaOrientation;
  }

  if (ariaOwns !== undefined) {
    elementProps['aria-owns'] = ariaOwns;
  }

  if (ariaRelevant !== undefined) {
    elementProps['aria-relevant'] = ariaRelevant;
  }

  if (ariaRoledescription !== undefined) {
    elementProps['aria-roledescription'] = ariaRoledescription;
  }

  if (autocapitalize !== undefined) {
    elementProps['autocapitalize'] = autocapitalize;
  }

  if (autofocus !== undefined) {
    elementProps['autofocus'] = autofocus;
  }

  if (contenteditable !== undefined) {
    elementProps['contenteditable'] = contenteditable;
  }

  if (dir !== undefined) {
    elementProps['dir'] = dir;
  }

  if (draggable !== undefined) {
    elementProps['draggable'] = draggable;
  }

  if (hidden !== undefined) {
    elementProps['hidden'] = hidden;
  }

  if (id !== undefined) {
    elementProps['id'] = id;
  }

  if (inputmode !== undefined) {
    elementProps['inputmode'] = inputmode;
  }

  if (lang !== undefined) {
    elementProps['lang'] = lang;
  }

  if (popover !== undefined) {
    elementProps['popover'] = popover;
  }

  if (reversed !== undefined) {
    elementProps['reversed'] = reversed;
  }

  if (role !== undefined) {
    elementProps['role'] = role;
  }

  if (slot !== undefined) {
    elementProps['slot'] = slot;
  }

  if (spellcheck !== undefined) {
    elementProps['spellcheck'] = spellcheck;
  }

  if (start !== undefined) {
    elementProps['start'] = start;
  }

  if (style !== undefined) {
    elementProps['style'] = style;
  }

  if (tabindex !== undefined) {
    elementProps['tabindex'] = tabindex;
  }

  if (title !== undefined) {
    elementProps['title'] = title;
  }

  if (translate !== undefined) {
    elementProps['translate'] = translate;
  }

  if (type !== undefined) {
    elementProps['type'] = type;
  }

  return React.createElement(
    'ol',
    elementProps,
    children
  );
};

Ol.displayName = 'Ol';
