/**
 * THIS FILE IS AUTOGENERATED. DO NOT EDIT IT.
 *
 * @generated December 28, 2025 11:40:34
 * @component Script
 * @description 
 */

export interface ScriptProps {
  /**
   * Child content or elements
   */
  children?: string | HTMLElement | (string | HTMLElement)[];
  /**
   * When present, it specifies that the script will be executed asynchronously as soon as it is available.
   */
  async?: boolean | null | undefined;
  /**
   * Specifies the character encoding for the resource.
   */
  charset?: string | null | undefined;
  /**
   * 
   */
  crossorigin?: string | boolean | null | undefined;
  /**
   * When present, it specifies that the script should be executed after the page has been parsed.
   */
  defer?: boolean | null | undefined;
  /**
   * Indicates whether the element is hidden
   */
  hidden?: boolean | null | undefined;
  /**
   * Specifies the integrity value of a resource.
   */
  integrity?: string | null | undefined;
  /**
   * Specifies the primary language for the element's content
   */
  lang?: string | null | undefined;
  /**
   * Specifies a cryptographic nonce that can be used in Content Security Policy (CSP) checks.
   */
  nonce?: string | null | undefined;
  /**
   * Specifies the referrer policy for fetches initiated by the element.
   */
  referrerpolicy?: string | boolean | null | undefined;
  /**
   * Specifies the URL of the external resource to be embedded or referenced.
   */
  src?: string | null | undefined;
  /**
   * Represents a title or tooltip for the element
   */
  title?: string | null | undefined;
  /**
   * Specifies the media type of the linked resource.
   */
  type?: string | boolean | null | undefined;
}

/**
 * Script - 
 */
export class Script {
  private element: HTMLElement;

  constructor(props: ScriptProps = {}) {
    this.element = document.createElement('script');
    this.applyProps(props);
  }

  private applyProps(props: ScriptProps): void {
    if (props.children !== undefined) {
      this.setChildren(props.children);
    }
    if (props.async !== undefined) {
      this.element.setAttribute('async', String(props.async));
    }
    if (props.charset !== undefined) {
      this.element.setAttribute('charset', String(props.charset));
    }
    if (props.crossorigin !== undefined) {
      this.setCrossorigin(props.crossorigin);
    }
    if (props.defer !== undefined) {
      this.element.setAttribute('defer', String(props.defer));
    }
    if (props.hidden !== undefined) {
      this.element.setAttribute('hidden', String(props.hidden));
    }
    if (props.integrity !== undefined) {
      this.element.setAttribute('integrity', String(props.integrity));
    }
    if (props.lang !== undefined) {
      this.element.setAttribute('lang', String(props.lang));
    }
    if (props.nonce !== undefined) {
      this.element.setAttribute('nonce', String(props.nonce));
    }
    if (props.referrerpolicy !== undefined) {
      this.setReferrerpolicy(props.referrerpolicy);
    }
    if (props.src !== undefined) {
      this.element.setAttribute('src', String(props.src));
    }
    if (props.title !== undefined) {
      this.element.setAttribute('title', String(props.title));
    }
    if (props.type !== undefined) {
      this.setType(props.type);
    }
  }

  setAsync(value: boolean | null | undefined): this {
    if (value === true) {
      this.element.setAttribute('async', '');
    } else {
      this.element.removeAttribute('async');
    }
    return this;
  }

  setCharset(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('charset');
    } else {
      this.element.setAttribute('charset', String(value));
    }
    return this;
  }

  setCrossorigin(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('crossorigin');
    } else {
      this.element.setAttribute('crossorigin', String(value));
    }
    return this;
  }

  setDefer(value: boolean | null | undefined): this {
    if (value === true) {
      this.element.setAttribute('defer', '');
    } else {
      this.element.removeAttribute('defer');
    }
    return this;
  }

  setHidden(value: boolean | null | undefined): this {
    if (value === true) {
      this.element.setAttribute('hidden', '');
    } else {
      this.element.removeAttribute('hidden');
    }
    return this;
  }

  setIntegrity(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('integrity');
    } else {
      this.element.setAttribute('integrity', String(value));
    }
    return this;
  }

  setLang(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('lang');
    } else {
      this.element.setAttribute('lang', String(value));
    }
    return this;
  }

  setNonce(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('nonce');
    } else {
      this.element.setAttribute('nonce', String(value));
    }
    return this;
  }

  setReferrerpolicy(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('referrerpolicy');
    } else {
      this.element.setAttribute('referrerpolicy', String(value));
    }
    return this;
  }

  setSrc(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('src');
    } else {
      this.element.setAttribute('src', String(value));
    }
    return this;
  }

  setTitle(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('title');
    } else {
      this.element.setAttribute('title', String(value));
    }
    return this;
  }

  setType(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('type');
    } else {
      this.element.setAttribute('type', String(value));
    }
    return this;
  }

  setChildren(children: string | HTMLElement | (string | HTMLElement)[]): this {
    // Clear existing children
    while (this.element.firstChild) {
      this.element.removeChild(this.element.firstChild);
    }
    
    if (typeof children === 'string') {
      this.element.textContent = children;
    } else if (Array.isArray(children)) {
      children.forEach(child => {
        if (typeof child === 'string') {
          this.element.appendChild(document.createTextNode(child));
        } else {
          this.element.appendChild(child);
        }
      });
    } else {
      this.element.appendChild(children);
    }
    return this;
  }

  getElement(): HTMLElement {
    return this.element;
  }
}
