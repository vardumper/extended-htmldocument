/**
 * THIS FILE IS AUTOGENERATED. DO NOT EDIT IT.
 *
 * @generated December 28, 2025 12:26:31
 * @component Colgroup
 * @description 
 */

export interface ColgroupProps {
  /**
   * Child content or elements
   */
  children?: string | HTMLElement | (string | HTMLElement)[];
  /**
   * Represents the text direction of the element
   */
  dir?: 'ltr' | 'rtl' | 'auto' | null | undefined;
  /**
   * Indicates whether the element is hidden
   */
  hidden?: boolean | null | undefined;
  /**
   * Specifies the primary language for the element's content
   */
  lang?: string | null | undefined;
  /**
   * Represents a slot in a shadow DOM
   */
  slot?: string | null | undefined;
  /**
   * Specifies the number of columns the <col> element should span in a table.
   */
  span?: number | null | undefined;
  /**
   * Represents the CSS inline style of the element
   */
  style?: string | null | undefined;
}

/**
 * Colgroup - 
 */
export class Colgroup {
  private element: HTMLElement;

  constructor(props: ColgroupProps = {}) {
    this.element = document.createElement('colgroup');
    this.applyProps(props);
  }

  private applyProps(props: ColgroupProps): void {
    if (props.children !== undefined) {
      this.setChildren(props.children);
    }
    if (props.dir !== undefined) {
      this.setDir(props.dir);
    }
    if (props.hidden !== undefined) {
      this.element.setAttribute('hidden', String(props.hidden));
    }
    if (props.lang !== undefined) {
      this.element.setAttribute('lang', String(props.lang));
    }
    if (props.slot !== undefined) {
      this.element.setAttribute('slot', String(props.slot));
    }
    if (props.span !== undefined) {
      this.element.setAttribute('span', String(props.span));
    }
    if (props.style !== undefined) {
      this.element.setAttribute('style', String(props.style));
    }
  }

  setDir(value: 'ltr' | 'rtl' | 'auto' | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('dir');
    } else {
      this.element.setAttribute('dir', String(value));
    }
    return this;
  }

  setHidden(value: boolean | null | undefined): this {
    if (value === true) {
      this.element.setAttribute('hidden', '');
    } else {
      this.element.removeAttribute('hidden');
    }
    return this;
  }

  setLang(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('lang');
    } else {
      this.element.setAttribute('lang', String(value));
    }
    return this;
  }

  setSlot(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('slot');
    } else {
      this.element.setAttribute('slot', String(value));
    }
    return this;
  }

  setSpan(value: number | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('span');
    } else {
      this.element.setAttribute('span', String(value));
    }
    return this;
  }

  setStyle(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('style');
    } else {
      this.element.setAttribute('style', String(value));
    }
    return this;
  }

  setChildren(children: string | HTMLElement | (string | HTMLElement)[]): this {
    // Clear existing children
    while (this.element.firstChild) {
      this.element.removeChild(this.element.firstChild);
    }
    
    if (typeof children === 'string') {
      this.element.textContent = children;
    } else if (Array.isArray(children)) {
      children.forEach(child => {
        if (typeof child === 'string') {
          this.element.appendChild(document.createTextNode(child));
        } else {
          this.element.appendChild(child);
        }
      });
    } else {
      this.element.appendChild(children);
    }
    return this;
  }

  getElement(): HTMLElement {
    return this.element;
  }
}
