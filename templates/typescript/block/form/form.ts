/**
 * THIS FILE IS AUTOGENERATED. DO NOT EDIT IT.
 *
 * @generated December 28, 2025 11:40:34
 * @component Form
 * @description 
 */

export interface FormProps {
  /**
   * Child content or elements
   */
  children?: string | HTMLElement | (string | HTMLElement)[];
  /**
   * Specifies the character encodings that are to be used for form submission.
   */
  'accept-charset'?: string | null | undefined;
  /**
   * specifies a shortcut key (or keys) to activate or focus an element
   */
  accesskey?: string | null | undefined;
  /**
   * Specifies the URL where the form data should be submitted when the form is submitted.
   */
  action?: string | null | undefined;
  /**
   * Indicates whether assistive technologies should present the entire region as a whole when changes occur.
   */
  'aria-atomic'?: string | boolean | null | undefined;
  /**
   * References an element that provides additional details about the current element.
   */
  'aria-details'?: string | null | undefined;
  /**
   * Indicates that the value entered does not conform to the expected format.
   */
  'aria-invalid'?: string | boolean | null | undefined;
  /**
   * Defines keyboard shortcuts available for the element.
   */
  'aria-keyshortcuts'?: string | null | undefined;
  /**
   * Defines a string value that labels the current element for assistive technologies.
   */
  'aria-label'?: string | null | undefined;
  /**
   * Defines how updates to the element should be announced to screen readers.
   */
  'aria-live'?: string | boolean | null | undefined;
  /**
   * Indicates what content changes should be announced in a live region.
   */
  'aria-relevant'?: string | boolean | null | undefined;
  /**
   * Provides a human-readable custom role description for assistive technologies.
   */
  'aria-roledescription'?: string | null | undefined;
  /**
   * Specifies whether a form or input field should have autocomplete enabled. Default is on.
   */
  autocomplete?: string | boolean | null | undefined;
  /**
   * Specifies controls whether autocorrection of editable text is enabled for spelling and/or punctuation errors. Default is on.
   */
  autocorrect?: string | boolean | null | undefined;
  /**
   * Represents the text direction of the element
   */
  dir?: string | boolean | null | undefined;
  /**
   * Indicates whether the element is draggable
   */
  draggable?: boolean | null | undefined;
  /**
   * Specifies how form data should be encoded before sending it to a server. Only used if the method attribute is set to post. Default is application/x-www-form-urlencoded.
   */
  enctype?: string | boolean | null | undefined;
  /**
   * Indicates whether the element is hidden
   */
  hidden?: boolean | null | undefined;
  /**
   * Specifies the primary language for the element's content
   */
  lang?: string | null | undefined;
  /**
   * 
   */
  method?: string | boolean | null | undefined;
  /**
   * Specifies the name associated with the element. The meaning may vary depending on the context.
   */
  name?: string | null | undefined;
  /**
   * When present, it specifies that a form should not be validated when submitted.
   */
  novalidate?: boolean | null | undefined;
  /**
   * Represents a slot in a shadow DOM
   */
  slot?: string | null | undefined;
  /**
   * Represents the CSS inline style of the element
   */
  style?: string | null | undefined;
  /**
   * Represents a tab order of the element
   */
  tabindex?: number | null | undefined;
  /**
   * Specifies where to open the linked document.
   */
  target?: string | boolean | null | undefined;
  /**
   * Represents a title or tooltip for the element
   */
  title?: string | null | undefined;
  /**
   * used to tell user agents whether the content should be translated.
   */
  translate?: string | boolean | null | undefined;
}

/**
 * Form - 
 */
export class Form {
  private element: HTMLElement;

  constructor(props: FormProps = {}) {
    this.element = document.createElement('form');
    this.applyProps(props);
  }

  private applyProps(props: FormProps): void {
    if (props.children !== undefined) {
      this.setChildren(props.children);
    }
    if (props['accept-charset'] !== undefined) {
      this.element.setAttribute('accept-charset', String(props['accept-charset']));
    }
    if (props.accesskey !== undefined) {
      this.element.setAttribute('accesskey', String(props.accesskey));
    }
    if (props.action !== undefined) {
      this.element.setAttribute('action', String(props.action));
    }
    if (props['aria-atomic'] !== undefined) {
      this.setAriaAtomic(props['aria-atomic']);
    }
    if (props['aria-details'] !== undefined) {
      this.element.setAttribute('aria-details', String(props['aria-details']));
    }
    if (props['aria-invalid'] !== undefined) {
      this.setAriaInvalid(props['aria-invalid']);
    }
    if (props['aria-keyshortcuts'] !== undefined) {
      this.element.setAttribute('aria-keyshortcuts', String(props['aria-keyshortcuts']));
    }
    if (props['aria-label'] !== undefined) {
      this.element.setAttribute('aria-label', String(props['aria-label']));
    }
    if (props['aria-live'] !== undefined) {
      this.setAriaLive(props['aria-live']);
    }
    if (props['aria-relevant'] !== undefined) {
      this.setAriaRelevant(props['aria-relevant']);
    }
    if (props['aria-roledescription'] !== undefined) {
      this.element.setAttribute('aria-roledescription', String(props['aria-roledescription']));
    }
    if (props.autocomplete !== undefined) {
      this.setAutocomplete(props.autocomplete);
    }
    if (props.autocorrect !== undefined) {
      this.setAutocorrect(props.autocorrect);
    }
    if (props.dir !== undefined) {
      this.setDir(props.dir);
    }
    if (props.draggable !== undefined) {
      this.element.setAttribute('draggable', String(props.draggable));
    }
    if (props.enctype !== undefined) {
      this.setEnctype(props.enctype);
    }
    if (props.hidden !== undefined) {
      this.element.setAttribute('hidden', String(props.hidden));
    }
    if (props.lang !== undefined) {
      this.element.setAttribute('lang', String(props.lang));
    }
    if (props.method !== undefined) {
      this.setMethod(props.method);
    }
    if (props.name !== undefined) {
      this.element.setAttribute('name', String(props.name));
    }
    if (props.novalidate !== undefined) {
      this.element.setAttribute('novalidate', String(props.novalidate));
    }
    if (props.slot !== undefined) {
      this.element.setAttribute('slot', String(props.slot));
    }
    if (props.style !== undefined) {
      this.element.setAttribute('style', String(props.style));
    }
    if (props.tabindex !== undefined) {
      this.element.setAttribute('tabindex', String(props.tabindex));
    }
    if (props.target !== undefined) {
      this.setTarget(props.target);
    }
    if (props.title !== undefined) {
      this.element.setAttribute('title', String(props.title));
    }
    if (props.translate !== undefined) {
      this.setTranslate(props.translate);
    }
  }

  setAcceptCharset(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('accept-charset');
    } else {
      this.element.setAttribute('accept-charset', String(value));
    }
    return this;
  }

  setAccesskey(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('accesskey');
    } else {
      this.element.setAttribute('accesskey', String(value));
    }
    return this;
  }

  setAction(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('action');
    } else {
      this.element.setAttribute('action', String(value));
    }
    return this;
  }

  setAriaAtomic(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('aria-atomic');
    } else {
      this.element.setAttribute('aria-atomic', String(value));
    }
    return this;
  }

  setAriaDetails(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('aria-details');
    } else {
      this.element.setAttribute('aria-details', String(value));
    }
    return this;
  }

  setAriaInvalid(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('aria-invalid');
    } else {
      this.element.setAttribute('aria-invalid', String(value));
    }
    return this;
  }

  setAriaKeyshortcuts(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('aria-keyshortcuts');
    } else {
      this.element.setAttribute('aria-keyshortcuts', String(value));
    }
    return this;
  }

  setAriaLabel(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('aria-label');
    } else {
      this.element.setAttribute('aria-label', String(value));
    }
    return this;
  }

  setAriaLive(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('aria-live');
    } else {
      this.element.setAttribute('aria-live', String(value));
    }
    return this;
  }

  setAriaRelevant(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('aria-relevant');
    } else {
      this.element.setAttribute('aria-relevant', String(value));
    }
    return this;
  }

  setAriaRoledescription(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('aria-roledescription');
    } else {
      this.element.setAttribute('aria-roledescription', String(value));
    }
    return this;
  }

  setAutocomplete(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('autocomplete');
    } else {
      this.element.setAttribute('autocomplete', String(value));
    }
    return this;
  }

  setAutocorrect(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('autocorrect');
    } else {
      this.element.setAttribute('autocorrect', String(value));
    }
    return this;
  }

  setDir(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('dir');
    } else {
      this.element.setAttribute('dir', String(value));
    }
    return this;
  }

  setDraggable(value: boolean | null | undefined): this {
    if (value === true) {
      this.element.setAttribute('draggable', '');
    } else {
      this.element.removeAttribute('draggable');
    }
    return this;
  }

  setEnctype(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('enctype');
    } else {
      this.element.setAttribute('enctype', String(value));
    }
    return this;
  }

  setHidden(value: boolean | null | undefined): this {
    if (value === true) {
      this.element.setAttribute('hidden', '');
    } else {
      this.element.removeAttribute('hidden');
    }
    return this;
  }

  setLang(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('lang');
    } else {
      this.element.setAttribute('lang', String(value));
    }
    return this;
  }

  setMethod(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('method');
    } else {
      this.element.setAttribute('method', String(value));
    }
    return this;
  }

  setName(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('name');
    } else {
      this.element.setAttribute('name', String(value));
    }
    return this;
  }

  setNovalidate(value: boolean | null | undefined): this {
    if (value === true) {
      this.element.setAttribute('novalidate', '');
    } else {
      this.element.removeAttribute('novalidate');
    }
    return this;
  }

  setSlot(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('slot');
    } else {
      this.element.setAttribute('slot', String(value));
    }
    return this;
  }

  setStyle(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('style');
    } else {
      this.element.setAttribute('style', String(value));
    }
    return this;
  }

  setTabindex(value: number | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('tabindex');
    } else {
      this.element.setAttribute('tabindex', String(value));
    }
    return this;
  }

  setTarget(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('target');
    } else {
      this.element.setAttribute('target', String(value));
    }
    return this;
  }

  setTitle(value: string | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('title');
    } else {
      this.element.setAttribute('title', String(value));
    }
    return this;
  }

  setTranslate(value: string | boolean | null | undefined): this {
    if (value === null || value === undefined) {
      this.element.removeAttribute('translate');
    } else {
      this.element.setAttribute('translate', String(value));
    }
    return this;
  }

  setChildren(children: string | HTMLElement | (string | HTMLElement)[]): this {
    // Clear existing children
    while (this.element.firstChild) {
      this.element.removeChild(this.element.firstChild);
    }
    
    if (typeof children === 'string') {
      this.element.textContent = children;
    } else if (Array.isArray(children)) {
      children.forEach(child => {
        if (typeof child === 'string') {
          this.element.appendChild(document.createTextNode(child));
        } else {
          this.element.appendChild(child);
        }
      });
    } else {
      this.element.appendChild(children);
    }
    return this;
  }

  getElement(): HTMLElement {
    return this.element;
  }
}
